# 平米內參 - 開發者聖經 (Developer Bible) v146.0

**版本**: 1.0.0
**最後更新**: 2025-09-04
**主要貢獻者**: SQM AI Engineer

---

## 第一章：哲學與願景 (Philosophy & Vision)

### 1.1 我們的使命：從數據混沌中提煉不動產洞見

「平米內參」的誕生，源於一個核心的痛點：台灣的不動產實價登錄數據，雖然公開透明，卻是一座蘊含巨大價值但開採極其困難的金礦。原始數據充滿了格式不一、定義模糊、結構混亂的問題，使得即便是資深的市場分析師，也需要耗費大量的時間進行數據清洗與人工判讀，才能勉強得出可用的結論。

我們的使命，就是利用精巧的軟體工程與數據科學，**將這種高摩擦力、低效率的數據探索過程，轉化為一個即時、互動、且富有洞察力的決策支援系統**。我們致力於成為不動產專業人士（包括代銷、仲介、建商、估價師及投資者）在面對複雜市場時，最值得信賴的「數位參謀」。

### 1.2 設計哲學：直覺、精準、可擴展

本專案的每一行程式碼，都圍繞著以下三個核心哲學：

1.  **直覺性 (Intuitive)**: 功能的設計必須符合使用者的心智模型。使用者不應需要閱讀冗長的手冊，就能透過介面直觀地理解數據的意義。例如，「銷控表分析」的介面，就是刻意模仿了代銷案場常見的銷控表格局，讓使用者能夠零成本上手。
2.  **精準性 (Precise)**: 數據分析的結果必須忠於事實，且其計算邏輯必須清晰、可被檢驗。我們寧可放棄一個看似酷炫但邏輯上存在瑕疵的功能，也要確保呈現給使用者的每一個數字、每一張圖表，背後都有站得住腳的演算法支撐。這體現在我們對「房屋單價」近乎苛刻的計算方式，以及對「戶別」解析的執著上。
3.  **可擴展性 (Scalable)**: 系統的架構必須能夠應對未來的挑戰。無論是數據量的增長（從單一縣市擴展至全國）、分析維度的增加（從價格分析擴展至使用者行為分析），還是功能的橫向擴充（從預售屋延伸至中古屋、租賃市場），現有架構都應能從容應對，而非推倒重來。

---

## 第二章：系統架構深度剖析 (In-depth Architecture Analysis)

本系統採用了基於 Supabase 的 Serverless 架構，實現了徹底的前後端分離，旨在最大化開發效率、安全性與可維護性。

### 2.1 宏觀架構圖

┌───────────────────┐      ┌───────────────────────────────┐      ┌───────────────────────────────┐
│   使用者瀏覽器     │      │      Supabase 雲端平台         │      │      Supabase Postgres 資料庫   │
├───────────────────┤      ├───────────────────────────────┤      ├───────────────────────────────┤
│                   │      │                               │      │                               │
│  [前端應用]       │      │                               │      │  ┌─────────────────────────┐  │
│  - index.html     │      │                               │      │  │    原始實價登錄資料表     │  │
│  - js/app.js      │      │                               │      │  │  (e.g., a_lvr_land_b)   │  │
│  - js/state.js    │      │                               │      │  └────────────┬────────────┘  │
│  - js/renderers/* │      │                               │      │               │ (Read)        │
│                   │      │                               │      │  ┌────────────┴────────────┐  │
└─────────┬─────────┘      │                               │      │  │   資料庫觸發器 (Triggers) │  │
│ (1. HTTPS API Request) │                               │      │  │ fn_calculate_fields() │  │
│                │      [後端服務: Edge Functions]    │      │  └─────────────────────────┘  │
│────────────────>│      - analyze-project-ranking  │      │                               │
│                │      - query-data                 │      │                               │
│                │      - ... (etc)                  │      │                               │
│                │              │                    │      │                               │
│                │      (4. DB Query)│                    │      │                               │
│                │              └────────────────────────>│                               │
│                │                               │      │                               │
│                │              ┌────────────────────────<│                               │
│                │      (5. DB Result)│                   │      │                               │
│                │                               │      │                               │
│                │  [核心邏輯 (Shared)]          │      │                               │
│                │  - analysis-engine.ts         │      │                               │
│                │  - unit-parser.ts             │      │                               │
│ (3. JSON Response)│              │                    │      │                               │
│<────────────────┘      (2. Invoke Logic)           │      │                               │
│                                  │                    │      │                               │
└─────────┘                                  └────────────────────┘      └───────────────────────────────┘


### 2.2 核心功能生命週期：以「銷控表分析」為例

為了具體理解系統的運作，讓我們追蹤一次完整的「銷控表分析」請求流程：

1.  **使用者互動**: 使用者在介面上選定「臺北市」、「信義區」，並從下拉列表中選擇建案「信義A5」。隨後，點擊「銷控表分析」按鈕。
2.  **前端狀態變更**: `js/eventHandlers.js` 捕捉到點擊事件。它從 DOM 元素中讀取使用者選擇的參數，並更新 `js/state.js` 中的全域狀態物件，例如 `state.selectedCity = 'A'`, `state.selectedDistrict = '信義區'`, `state.selectedProject = '信義A5'`。
3.  **API 請求觸發**: 狀態更新後，事件處理器呼叫 `js/api.js` 中的 `fetchPriceGridData` 函式。此函式會從 `state.js` 讀取必要的參數，並建構一個 `POST` 請求。請求的 body 內容類似：`{ city: 'A', district: '信義區', projectName: '信義A5' }`。請求的目標是 Supabase 的 `query-data` Edge Function。
4.  **Edge Function 接收與驗證**: `supabase/functions/query-data/index.ts` 接收到此請求。它首先會進行基本的參數驗證，確保 `city`, `district`, `projectName` 等必要欄位存在且格式正確。
5.  **核心邏輯調用**: 驗證通過後，`query-data` 端點會從 Supabase 資料庫中，根據提供的參數查詢「信義A5」建案的所有交易原始數據。
6.  **數據清洗與正規化**: 查詢到的原始數據被傳遞給 `_shared/unit-parser.ts`。`unit-parser` 會逐筆遍歷交易數據，對 `transaction_unit` (戶別) 欄位進行解析和正規化，為每一筆交易生成一個標準化的 `finalUnitId`。
7.  **數據分析與計算**: 經過正規化的數據集，接著被傳遞給 `_shared/analysis-engine.ts` 中的 `calculatePriceGridAnalysis` 函式。這個函式是整個流程的「大腦」，它會執行複雜的計算，包括：
    * 尋找每個戶型（A1, A2...）的「基準戶 (Anchor Unit)」。
    * 計算每筆交易相對於其基準戶的樓層價差。
    * 聚合數據，形成一個以 `finalUnitId` 為 key，內部包含各樓層交易詳情的巢狀物件結構。
8.  **JSON 數據回傳**: `analysis-engine` 計算完成後，返回一個巨大的 JSON 物件。Edge Function 將此 JSON 作為 HTTP 回應的主體，並設定 `Content-Type: application/json`，回傳給前端。
9.  **前端接收與儲存**: `js/api.js` 中的 `fetch` 呼叫的 `Promise` 被 resolve，前端獲得了這個 JSON 物件。它會將這個結果儲存到 `state.js` 的 `state.priceGridData` 中。
10. **UI 渲染**: 數據儲存後，API 模組會呼叫 `js/renderers/tables.js` 中的 `renderPriceGrid` 函式。此函式會讀取 `state.priceGridData` 的數據，動態生成銷控表的 HTML `<table>` 結構，並將其插入到頁面的指定容器中。同時，它也會為表格中的儲存格綁定事件監聽器（例如點擊顯示詳細資訊）。

### 2.3 技術選型考量 (Why this stack?)

-   **Why Vanilla JavaScript?**: 在專案初期，我們選擇了原生 JS 而非 React/Vue 等框架。這是基於以下考量：
    1.  **性能**: 對於一個重數據、輕互動的儀表板應用，原生 JS 搭配精細的 DOM 操作，可以避免大型框架帶來的額外性能開銷和載入時間。
    2.  **可控性**: 我們需要對 DOM 的渲染時機和方式有完全的控制權，尤其是在處理 ApexCharts 這類需要直接操作 DOM 元素的圖表庫時。
    3.  **零依賴**: 減少了專案的構建複雜度和潛在的依賴性問題。
-   **Why Supabase?**: Supabase 提供了一個整合度極高的後端即服務 (BaaS) 平台，完美契合本專案的需求：
    1.  **Postgres as the Core**: 它提供了一個功能完整的 PostgreSQL 資料庫，讓我們可以利用 SQL 的強大能力，以及 PostGIS 進行地理空間查詢，並能透過 Triggers 實現複雜的數據自動化處理。
    2.  **Serverless Edge Functions**: Deno-based 的 Edge Functions 讓我們可以用 TypeScript 編寫後端邏輯，無需管理伺服器。其全球分佈的特性也保證了低延遲的 API 回應。
    3.  **整合性**: Auth, Storage, Database, Functions 之間無縫整合，大幅簡化了開發流程。
-   **Why Tailwind CSS?**:
    1.  **快速開發**: Utility-first 的方法讓我們可以直接在 HTML 中快速建構出複雜的 UI，而無需在 CSS 和 JS 之間頻繁切換上下文。
    2.  **高度客製化**: 易於配置的 `tailwind.config.js` 讓我們可以定義專案專屬的設計系統（顏色、間距、字體等）。
    3.  **小體積**: 透過 PurgeCSS，最終輸出的 CSS 檔案只會包含實際使用到的樣式，體積極小。

---

## 第三章：後端核心引擎詳解 (`supabase/functions/`)

後端是本系統的「智慧中樞」，所有數據的處理與分析都在 Edge Functions 中完成。

### 3.1 分析引擎 (`_shared/analysis-engine.ts`)

這是系統中最複雜、最具商業價值的模組。它將原始的資料庫數據轉化為富有洞見的分析結果。

#### **`calculatePriceGridAnalysis` (銷控表分析)**

-   **核心目的**: 模擬並超越傳統代銷案場的紙本銷控表，提供一個可互動、包含樓層價差校正的數位版本。
-   **演算法深度解析**:
    1.  **初始化**: 函式接收一個建案的所有交易數據陣列作為輸入。
    2.  **基準戶篩選 (Anchor Unit Selection)**:
        -   **動機**: 直接比較不同樓層的單價是沒有意義的（高樓層通常較貴）。為了進行公平的橫向比較（例如，比較 A1 戶和 A2 戶的真實價值），我們需要一個基準點來消除樓層價差的干擾。
        -   **流程**:
            a. 首先，將所有交易按 `finalUnitId` (例如 'A1', 'A2') 進行分組。
            b. 對於每一個分組（例如 'A1' 的所有交易），再按 `transaction_date` 進行排序，找出最早的交易日期。
            c. 選取所有在「最早交易日期後 14 天內」成交的交易。這個 14 天的窗口是為了捕捉建案開盤初期的定價，此時的價格最能反映產品的基礎價值。
            d. 在這個 14 天的窗口內，找出 `房屋單價(萬)` 最低的那一筆交易，將其定義為該戶型 (`A1`) 的「基準戶」。
            e. 將此基準戶的單價 (`anchorPrice`) 和樓層 (`anchorFloor`) 記錄下來。
    3.  **價差計算與數據聚合**:
        -   遍歷建案的**所有**交易（而不僅僅是基準戶）。
        -   對於每一筆交易，找到其 `finalUnitId` 對應的 `anchorPrice`。
        -   計算**樓層價差百分比**: `floorPremium = ((currentUnitPrice / anchorPrice) - 1) * 100`。這個值直觀地反映了該戶相較於其戶型基準戶的價格溢價。
        -   建構一個巨大的巢狀物件 `priceGrid`。其結構為：
            ```json
            {
              "A1": {
                "3": { "unitPrice": 205.5, "floorPremium": 2.75, ... },
                "5": { "unitPrice": 210.1, "floorPremium": 5.05, ... },
                // ... 其他樓層
                "anchorInfo": { "price": 200.0, "floor": 2 }
              },
              "A2": { ... }
            }
            ```
-   **回傳值**: 回傳 `priceGrid` 物件，前端可以直接使用此結構來渲染表格。

#### **`calculateUnitPriceAnalysis` (多維單價分析)**

-   **核心目的**: 解決一個常見的分析難題：「這個建案的店舖到底比住宅貴多少？」它需要精確地區分不同使用目的的產品，並進行加權比較。
-   **演算法深度解析**:
    1.  **數據分類 (Categorization with Mutual Exclusivity)**:
        -   **動機**: 在實價登錄中，一筆交易可能同時標記為「商業用」和「住商用」，或在備註中提到「店舖」。如果簡單地進行多重計數，會導致數據污染。
        -   **流程**: 函式採用了一個帶有優先級的 `if...else if...else` 結構來確保每筆交易只會被歸入一個類別：
            a. **優先級 1 (店舖)**: 如果 `building_type` 包含 "店舖" 或 "店面"，則無論其他欄位是什麼，都將其歸類為 `shops`。這是因為店舖的商業價值最高，應被優先識別。
            b. **優先級 2 (商辦)**: 如果不滿足上一條件，且 `main_purpose` 包含 "商業" 或 "辦公"，則歸類為 `offices`。
            c. **優先級 3 (住宅)**: 如果以上皆不滿足，且 `main_purpose` 包含 "住宅" 或 `building_type` 包含 "住宅"，則歸類為 `residences`。
            d. **其他**: 不符合上述任何條件的交易，會被歸入 `others` 類別，並在計算中排除。
    2.  **坪數加權平均 (Area-Weighted Average)**:
        -   **動機**: 直接計算單價的算術平均值，會受到極端值（例如，一筆極小坪數但單價極高的交易）的嚴重影響，從而扭曲整體市場的認知。
        -   **公式**: `加權平均單價 = Σ(單價 * 房屋坪數) / Σ(房屋坪數)`
        -   **流程**: 對於 `shops`, `offices`, `residences` 三個類別，分別計算其加權平均單價。
    3.  **倍數計算 (Multiplier Calculation)**:
        -   計算 `shopMultiplier = shops.weightedAvgPrice / residences.weightedAvgPrice`
        -   計算 `officeMultiplier = offices.weightedAvgPrice / residences.weightedAvgPrice`
-   **回傳值**: 回傳一個包含各類別統計數據（總銷金額、總坪數、成交件數、加權平均單價）和倍數的 JSON 物件。

### 3.2 戶別解析器 (`_shared/unit-parser.ts`)

這是本專案的「秘密武器」，是將髒數據轉化為可用資訊的關鍵。

-   **面臨的挑戰**: 戶別資訊在原始數據中是個非結構化的字串欄位，常見的混亂格式包括：
    -   `A1-15F`, `A1棟15樓` (標準格式)
    -   `B棟五樓` (中文數字)
    -   `C2戶` (無樓層資訊)
    -   `D-1-12` (多重分隔符)
    -   `E1 (露台戶)` (包含註釋)
    -   `1F-G` (樓層在前)

-   **兩階段自適應解析演算法**:
    1.  **第一階段：廣譜模式匹配 (Broad-Spectrum Pattern Matching)**
        -   函式內建了一個包含約 10-15 個高頻正規表示式 (RegExp) 的規則庫。
        -   這些 RegExp 被精心設計，以捕捉最常見的戶別命名模式，例如 `(A-Z)(\d{1,2})` 用於匹配 `A1` 這種格式。
        -   對於每一筆輸入的戶別字串，系統會遍歷整個規則庫，嘗試匹配。一旦成功匹配並提取出標準化的戶別 ID（如 `A1`），則解析成功，進入下一筆數據。
    2.  **第二階段：自適應校正 (Adaptive Correction)**
        -   **動機**: 第一階段結束後，可能仍有 5-10% 的戶別無法解析，或者解析出的結果風格迥異（例如，同一個建案同時出現 `A1` 和 `1A` 兩種格式）。
        -   **流程**:
            a. **主流風格檢測**: 統計在第一階段中成功解析出的所有戶別 ID，分析其命名「風格」。例如，是「字母+數字」(`A1`) 還是「數字+字母」(`1A`) 佔主導地位。
            b. **二次打撈**: 對於所有在第一階段解析失敗的戶別，啟用一個更寬鬆、或針對主流風格的「二次解析規則庫」。例如，如果主流風格是 `A1`，那麼在二次解析中，會嘗試將 `1棟A戶` 也轉換為 `A1`。
            c. **風格統一**: 對於那些解析結果不符合主流風格的戶別，系統會嘗試進行翻轉或重組，使其符合主流風格。
-   **價值**: 這個獨創的解析器，將戶別辨識的準確率從僅使用簡單 RegExp 的約 80% 提升到了 95% 以上，這是所有後續分析（特別是銷控表）能夠精準呈現的基石。

---

## 第四章：資料庫設計與管理

### 4.1 資料表命名範式

-   **核心規則**: `[縣市代碼]_[資料源]_[資料類型]_[交易類型]`
-   **設計理念**: 這種命名方式將資料庫的元數據 (Metadata) 直接編碼到表名中。這帶來了幾個好處：
    1.  **查詢效率**: 後端邏輯可以根據使用者的選擇（例如，城市、交易類型），動態地構建出要查詢的表名，而無需在一個巨大的、包含所有縣市的單一表格中進行低效率的 `WHERE city = 'A'` 查詢。
    2.  **可管理性**: 資料的導入、備份、索引重建等維護工作，可以按縣市、按類型分批進行，管理更為精細。
    3.  **可擴展性**: 當未來需要引入新的資料源（例如，`rent_data`）或新的交易類型時，只需按照此範式創建新表即可，對現有系統無任何侵入。

### 4.2 關鍵欄位與資料庫自動化

-   **`"房屋單價(萬)"` - 系統的黃金指標**:
    -   **定義**: 這是系統中所有單價分析的唯一依據。它被定義為 **無車位的房屋單價**。
    -   **計算邏輯 (由 Trigger `fn_calculate_main_tables_fields` 實現)**:
        1.  `Total_Price_NTD`: 交易總價(元)
        2.  `Parking_Price_NTD`: 車位總價(元)
        3.  `Building_Area_M2`: 房屋面積(主建物+陽台)(平方公尺)
        4.  `坪`: 3.30579 (轉換係數)
        5.  `萬`: 10000
        6.  **公式**: `("Total_Price_NTD" - "Parking_Price_NTD") / ("Building_Area_M2" / 坪) / 萬`
    -   **自動化價值**: 將這個複雜且至關重要的計算放在資料庫 Trigger 層，保證了數據的一致性。無論數據是從哪個管道插入或更新，其單價的計算邏輯永遠是統一的，徹底避免了應用層邏輯不一致可能導致的數據錯誤。

---

## 第五章：前端架構與狀態管理

前端採用模組化的原生 JavaScript 編寫，核心是圍繞一個中央狀態物件 `state.js` 進行的單向數據流。

### 5.1 中央狀態管理器 (`js/state.js`)

-   **角色**: 它是整個前端應用的「單一事實來源 (Single Source of Truth)」。任何需要被多個模組共享的數據、UI 狀態、使用者選擇，都必須存儲在這裡。
-   **核心狀態變數**:
    -   `selectedCity`, `selectedDistrict`, `selectedProject`: 用戶當前的選擇。
    -   `projectRankingData`, `priceDistributionData`, `unitPriceAnalysisData`, `priceGridData`: 從後端 API 獲取的原始分析數據。
    -   `isHeatmapActive`: 控制銷控表當前是顯示標準視圖還是熱力圖視圖的布林值。
    -   `currentFilters`: 用戶應用的進階篩選條件（例如，只看三房、排除特殊交易）。
-   **工作流程**:
    1.  **Action (使用者操作)**: `eventHandlers.js` 監聽到用戶行為。
    2.  **Mutation (狀態變更)**: `eventHandlers.js` 或 `api.js` 修改 `state.js` 中的對應值。
    3.  **Reaction (UI 更新)**: 狀態變更後，會主動調用 `renderers/` 目錄下的相關渲染函式。
    4.  **Render**: 渲染函式讀取 `state.js` 的最新狀態，並將其反映到 DOM 上。
-   **優勢**: 這種模式避免了模組間的混亂耦合和數據不一致問題，使得程式碼的邏輯流向清晰，易於除錯和維護。

### 5.2 模組化渲染器 (`js/renderers/`)

-   **設計模式**: 每個 `renderer` 模組都遵循「單一職責原則」。
    -   `charts.js`: 專門負責使用 ApexCharts 渲染所有圖表（長條圖、直方圖等）。
    -   `tables.js`: 專門負責渲染所有表格型數據，特別是複雜的銷控表。
    -   `heatmap.js`: 負責在銷控表的基礎上，疊加熱力圖的邏輯和樣式。
    -   `uiComponents.js`: 負責渲染非數據驅動的 UI 元件，如篩選器、下拉選單等。
-   **協作方式**: 渲染器本身是無狀態的。它們的唯一任務就是忠實地將 `state.js` 中的數據轉換為 HTML。這種設計使得替換圖表庫或修改表格樣式變得非常簡單，只需修改對應的渲染模組，而不會影響到數據獲取和狀態管理的核心邏輯。

---

## 第六章：部署與未來展望

### 6.1 開發與部署流程

1.  **本地開發**:
    -   安裝 Supabase CLI。
    -   在專案根目錄執行 `supabase start`，啟動本地的 Supabase 服務（包括資料庫、Auth 和 Functions 的模擬器）。
    -   前端檔案可以直接用 Live Server 等工具在瀏覽器中開啟。
2.  **部署 Edge Functions**:
    -   修改完 `supabase/functions/` 下的任何函式後，執行 `supabase functions deploy [function-name]` 即可將其部署到雲端。
3.  **部署前端**:
    -   前端是純靜態檔案，可以部署在任何靜態網站託管服務上，如 Netlify, Vercel 或 GitHub Pages。

### 6.2 未來發展藍圖 (Roadmap)

-   **Q4 2025: 使用者系統與個人化儀表板**:
    -   引入 Supabase Auth，允許使用者註冊登入。
    -   開發「我的最愛」功能，讓使用者可以追蹤特定建案。
    -   建立個人化儀表板，儲存使用者常用的篩選條件和圖表佈局。
-   **Q1 2026: 擴展數據源 - 中古屋與租賃市場**:
    -   按照現有資料庫範式，引入中古屋 (`lvr_land_a`) 和租賃 (`rent_data`) 的數據表。
    -   擴充 `analysis-engine.ts`，加入針對中古屋的分析邏輯（例如，屋齡分析、持有時間分析）。
-   **Q2 2026: 機器學習應用 - 價格預測模型**:
    -   利用歷史成交數據，訓練一個基礎的房價預測模型。
    -   使用者在銷控表上點擊一個未售出的戶別時，模型可以給出一個基於其樓層、戶型、朝向的預估成交價區間。
